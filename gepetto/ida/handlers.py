import functools
import json
import re
import time
import textwrap

import idaapi
import ida_hexrays
import idc

import gepetto.config
from gepetto.models.model_manager import instantiate_model
from gepetto.ida.status_panel import get_status_panel

_ = gepetto.config._

STATUS_PANEL = get_status_panel()

def comment_callback(address, view, response, start_time):
    """Callback that sets a comment at the given address.

    :param address: The address of the function to comment
    :param view: A handle to the decompiler window
    :param response: The comment to add or a message object returned by the
        model.  When using tool-calling APIs the model might return a
        ``ChatCompletionMessage`` object instead of a simple string.  In order
    to remain backwards compatible this function accepts either and extracts
        the textual content when necessary.
    """
    elapsed_time = time.time() - start_time

    response_text = response.content if hasattr(response, "content") else response
    response_text = "\n".join(textwrap.wrap(response_text, 80, replace_whitespace=False))

    # Add the response as a comment in IDA, but preserve any existing non-Gepetto comment
    comment = idc.get_func_cmt(address, 0)
    comment = re.sub(
        r'----- ' + _("Comment generated by Gepetto") + ' -----.*?----------------------------------------',
        r"",
        comment,
        flags=re.DOTALL)

    idc.set_func_cmt(address, '----- ' + _("Comment generated by Gepetto") +
                     f" -----\n\n"
                     f"{response_text.strip()}\n\n"
                     f"----------------------------------------\n\n"
                     f"{comment.strip()}", 0)
    # Refresh the window so the comment is displayed properly
    if view:
        view.refresh_view(False)

    response_finished = STATUS_PANEL.log_request_finished(elapsed_time)
    print(response_finished)

# -----------------------------------------------------------------------------

def conversation_callback(response, memory):
    """Callback that prints the model's response in IDA's output window.

    The ``response`` argument can either be a plain string or a message object
    returned by :mod:`openai`.  Only the textual content is relevant here, so
    extract it if needed.
    """

    text = response.content if hasattr(response, "content") else response
    memory.append({"role": "assistant", "content": text})

    print()
    for line in text.split("\n"):
        if not line.strip():
            continue
        print(f"{str(gepetto.config.model)}> {line}")
    print()

# -----------------------------------------------------------------------------

class ExplainHandler(idaapi.action_handler_t):
    """
    This handler is tasked with querying the model for an explanation of the
    given function. Once the reply is received, it is added as a function
    comment.
    """

    def __init__(self):
        idaapi.action_handler_t.__init__(self)

    def activate(self, ctx):
        start_time = time.time()
        decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())
        v = ida_hexrays.get_widget_vdui(ctx.widget)
        gepetto.config.model.query_model_async(
            f"Can you explain what the following C function does and suggest a better name for it?\n"
            f"Your response should use the following locale as a language: {gepetto.config.get_localization_locale()}\n"
            f"{decompiler_output}",
            functools.partial(comment_callback, address=idaapi.get_screen_ea(), view=v, start_time=start_time))
        request_sent = STATUS_PANEL.log_request_started()
        print(request_sent)
        return 1

    # This action is always available.
    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS


# -----------------------------------------------------------------------------

def rename_callback(address, view, response):
    """
    Callback that extracts a JSON object of old names and new names from the response,
    displays a table UI where the user can select which identifiers to rename,
    and applies renaming only to selected items.
    :param address: The address of the function to work on
    :param view: A handle to the decompiler window
    :param response: The response from the model
    """
    import ida_kernwin
    import json
    import re

    response_text = response.content if hasattr(response, "content") else response
    names = json.loads(response_text)

    function_addr = idaapi.get_func(address).start_ea
    func_name = idc.get_func_name(function_addr)
    func_new_name = names.pop("__function__", None)

    rename_pairs = []
    if func_new_name and func_name.startswith("sub_"):
        rename_pairs.append((func_name, func_new_name))
    rename_pairs.extend((n, names[n]) for n in names)
    rename_mapping = {old: new for old, new in rename_pairs}

    class RenameChoose(ida_kernwin.Choose):
        def __init__(self, rename_pairs):
            super().__init__(
                "Select names to rename",
                [["Old Name", 20], ["New Name", 20]],
                flags=ida_kernwin.Choose.CH_MULTI,
            )
            self.items = [[old, new] for old, new in rename_pairs]
            self.selected_indices = []

        def OnGetLine(self, n):
            return self.items[n]

        def OnGetSize(self):
            return len(self.items)
            
        def OnSelectionChange(self, sel_list):
            self.selected_indices = sel_list

    chooser = RenameChoose(rename_pairs)
    if chooser.Show(modal=True) < 0:
        print("Rename cancelled by user.")
        return

    # Get all selected rows
    chosen_pairs = [rename_pairs[i] for i in chooser.selected_indices]

    replaced = []
    for old, new in chosen_pairs:
        if old == func_name:
            if idc.set_name(function_addr, new, idaapi.SN_FORCE):
                replaced.append(old)
        else:
            if idaapi.IDA_SDK_VERSION < 760:
                lvars = {lvar.name: lvar for lvar in view.cfunc.lvars}
                if old in lvars and view.rename_lvar(lvars[old], new, True):
                    replaced.append(old)
            else:
                if ida_hexrays.rename_lvar(function_addr, old, new):
                    replaced.append(old)

    comment = idc.get_func_cmt(address, 0)
    if comment and len(replaced) > 0:
        for n in replaced:
            if n in rename_mapping:
                comment = re.sub(r'\b%s\b' % n, rename_mapping[n], comment)
        idc.set_func_cmt(address, comment, 0)

    if view:
        view.refresh_view(True)
    response_finished = _("Done! {count} name(s) renamed.").format(count=len(replaced))
    print(response_finished)
    STATUS_PANEL.log(response_finished)


# -----------------------------------------------------------------------------

class RenameHandler(idaapi.action_handler_t):
    """
    This handler requests new names for the function and its variables from the model
    and updates the decompiler's output.
    """

    def __init__(self):
        idaapi.action_handler_t.__init__(self)

    def activate(self, ctx):
        decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())
        v = ida_hexrays.get_widget_vdui(ctx.widget)
        gepetto.config.model.query_model_async(
            f"Analyze the following C function:\n{decompiler_output}"
            f"\nSuggest better names for the variables and, if helpful, the function itself."
            f" Return a JSON object where keys are the original names and values are the suggested ones."
            f" Only include an entry when the proposed name is at least marginally better than the original."
            f" Use the special key '__function__' to rename the function. Do not provide any explanation,"
            f" only the JSON object.\n"
            f"Your response should suggest names in the following locale: {gepetto.config.get_localization_locale()}",
            functools.partial(rename_callback, address=idaapi.get_screen_ea(), view=v),
            additional_model_options={"response_format": {"type": "json_object"}})
        request_sent = STATUS_PANEL.log_request_started()
        print(request_sent)
        return 1

    # This action is always available.
    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS


# -----------------------------------------------------------------------------

class SwapModelHandler(idaapi.action_handler_t):
    """
    This handler replaces the model currently in use with another one selected by the user,
    and updates the configuration.
    """

    def __init__(self, new_model, plugin):
        self.new_model = new_model
        self.plugin = plugin

    def activate(self, ctx):
        try:
            gepetto.config.model = instantiate_model(self.new_model)
        except ValueError as e:  # Raised if an API key is missing. In which case, don't switch.
            error_msg = _("Couldn't change model to {model}: {error}").format(model=self.new_model, error=str(e))
            print(error_msg)
            STATUS_PANEL.log(error_msg)
            return
        gepetto.config.update_config("Gepetto", "MODEL", self.new_model)
        STATUS_PANEL.set_model(str(gepetto.config.model))
        # Refresh the menus to reflect which model is currently selected.
        self.plugin.generate_model_select_menu()

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS


class GenerateCCodeHandler(idaapi.action_handler_t):
    """
    This handler requests the model to generate executable C code from the given
    decompiled C function. The generated code is saved to a file.
    """
    def __init__(self):
        idaapi.action_handler_t.__init__(self)

    def activate(self, ctx):
        decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())
        v = ida_hexrays.get_widget_vdui(ctx.widget)
        if not decompiler_output:
            return 0

        gepetto.config.model.query_model_async(
            _("Please generate executable C code based on the following decompiled C code and ensure it includes all necessary header files and other information:\n{decompiler_output}").format(decompiler_output=str(decompiler_output)),
            functools.partial(self._save_c_code, view=v)
        )
        request_sent = STATUS_PANEL.log_request_started()
        print(request_sent)
        return 1

    def _save_c_code(self, view, response):
        """
        Callback that saves the generated C code to a file.
        :param view: A handle to the decompiler window
        :param response: The generated C code from the model
        """
        project_name = idaapi.get_root_filename()
        func_name = idc.get_func_name(idaapi.get_screen_ea())
        file_name = f"{project_name}_{func_name}.c"
        with open(file_name, "w", encoding="utf-8") as f:
            f.write(response)

        if view:
            view.refresh_view(False)
        response_finished = _("{model} generated code saved to {file_name}").format(
            model=str(gepetto.config.model), file_name=file_name)
        print(response_finished)
        STATUS_PANEL.log(response_finished)

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS


class GeneratePythonCodeHandler(idaapi.action_handler_t):
    """
    This handler requests the model to generate executable C code from the given
    decompiled C function. The generated code is saved to a file.
    """
    def __init__(self):
        idaapi.action_handler_t.__init__(self)

    def activate(self, ctx):
        decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())
        v = ida_hexrays.get_widget_vdui(ctx.widget)
        if not decompiler_output:
            return 0

        gepetto.config.model.query_model_async(
            _("Please generate equivalent Python code based on the following decompiled C code, and provide an example of the function call:\n{decompiler_output}").format(decompiler_output=str(decompiler_output)),
            functools.partial(self._save_python_code, view=v)
        )
        request_sent = STATUS_PANEL.log_request_started()
        print(request_sent)
        return 1

    def _save_python_code(self, view, response):
        """
        Callback that saves the generated python code to a file.
        :param view: A handle to the decompiler window
        :param response: The generated python code from the model
        """
        project_name = idaapi.get_root_filename()
        func_name = idc.get_func_name(idaapi.get_screen_ea())
        file_name = f"{project_name}_{func_name}.py"
        with open(file_name, "w", encoding="utf-8") as f:
            f.write(response)

        if view:
            view.refresh_view(False)
        response_finished = _("{model} generated code saved to {file_name}").format(
            model=str(gepetto.config.model), file_name=file_name)
        print(response_finished)
        STATUS_PANEL.log(response_finished)
        

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS
