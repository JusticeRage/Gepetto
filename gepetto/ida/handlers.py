import functools
import re
import time
import textwrap

import idaapi  # type: ignore
import ida_hexrays  # type: ignore
import idc  # type: ignore

import gepetto.config
from gepetto.ida.utils.thread_helpers import *
from gepetto.models.model_manager import instantiate_model
from gepetto.ida.status_panel.panel_interface import LogCategory, LogLevel
from gepetto.ida.status_panel.status_panel import get_status_panel

_ = gepetto.config._

STATUS_PANEL = get_status_panel()

def comment_callback(address, view, response, start_time):
    """Callback that sets a comment at the given address.

    :param address: The address of the function to comment
    :param view: A handle to the decompiler window
    :param response: The comment to add or a message object returned by the
        model.  When using tool-calling APIs the model might return a
        ``ChatCompletionMessage`` object instead of a simple string.  In order
    to remain backwards compatible this function accepts either and extracts
        the textual content when necessary.
    """

    response_text = response.content if hasattr(response, "content") else response
    if not isinstance(response_text, str):
        response_text = str(response_text)
    response_text = "\n".join(textwrap.wrap(response_text, 80, replace_whitespace=False))

    def _apply_comment():
        existing = idc.get_func_cmt(address, 0) or ""
        existing = re.sub(
            r'----- ' + _("Comment generated by Gepetto") + ' -----.*?----------------------------------------',
            r"",
            existing,
            flags=re.DOTALL,
        )
        new_comment = (
            '----- ' + _("Comment generated by Gepetto") + ' -----\n\n'
            f"{response_text.strip()}\n\n"
            "----------------------------------------\n\n"
            f"{existing.strip()}"
        )
        idc.set_func_cmt(address, new_comment, 0)
        if view:
            view.refresh_view(False)

    try:
        run_on_main_thread(_apply_comment, write=True)
    except Exception as exc:
        error_message = _("[ERROR] comment callback failed: {error}").format(error=str(exc))
        print(error_message)
        STATUS_PANEL.mark_error(error_message)
        return

    elapsed_time = time.time() - start_time
    response_finished = STATUS_PANEL.log_request_finished(elapsed_time)
    print(response_finished)

# -----------------------------------------------------------------------------

def conversation_callback(response, memory):
    """Callback that prints the model's response in IDA's output window.

    The ``response`` argument can either be a plain string or a message object
    returned by :mod:`openai`.  Only the textual content is relevant here, so
    extract it if needed.
    """

    text = response.content if hasattr(response, "content") else response
    if not isinstance(text, str):
        text = str(text)
    memory.append({"role": "assistant", "content": text})

    print()
    for line in text.split("\n"):
        if not line.strip():
            continue
        print(f"{str(gepetto.config.model)}> {line}")
    print()

# -----------------------------------------------------------------------------

class ExplainHandler(idaapi.action_handler_t):
    """
    This handler is tasked with querying the model for an explanation of the
    given function. Once the reply is received, it is added as a function
    comment.
    """

    def __init__(self):
        idaapi.action_handler_t.__init__(self)

    def activate(self, ctx):
        start_time = time.time()
        decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())
        v = ida_hexrays.get_widget_vdui(ctx.widget)
        locale = gepetto.config.get_localization_locale()
        gepetto.config.model.query_model_async(
            f"""
                You are a reverse-engineering assistant. Output plain text only (no Markdown, no code fences).
                - Locale: {locale}
                - Task: Summarize what the C function does and propose a clearer function name if one stands out.
                - Observations: Use any existing Gepetto-generated comments as hints but do not repeat them verbatim.
                - Response structure:
                    1. Brief explanation (2-4 sentences) covering purpose, key behaviours, and notable side effects.
                    2. Final line: "Proposed name: <name>" (use "(no change)" if you cannot recommend an improvement).

                ```C
                {decompiler_output}
                ```
              """,
            functools.partial(comment_callback, address=idaapi.get_screen_ea(), view=v, start_time=start_time))
        request_sent = STATUS_PANEL.log_request_started()
        print(request_sent)
        return 1

    # This action is always available.
    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS


# -----------------------------------------------------------------------------

def rename_callback(address, view, response, start_time):
    """
    Callback that extracts a JSON object of old names and new names from the response,
    displays a table UI where the user can select which identifiers to rename,
    and applies renaming only to selected items.
    :param address: The address of the function to work on
    :param view: A handle to the decompiler window
    :param response: The response from the model
    """
    import ida_kernwin
    import json
    import re

    elapsed_time = time.time() - start_time
    timer_finished = STATUS_PANEL.log_request_finished(elapsed_time)
    print(timer_finished)

    response_text = response.content if hasattr(response, "content") else response
    if not isinstance(response_text, str):
        response_text = str(response_text)
    try:
        names = json.loads(response_text)
    except Exception as exc:
        error_message = _("[ERROR] rename callback JSON failure: {error}").format(error=str(exc))
        print(error_message)
        STATUS_PANEL.mark_error(error_message)
        return

    names = dict(names)  # Work on a copy to avoid accidental mutation leakage.

    def _apply():
        function = idaapi.get_func(address)
        if function is None:
            raise RuntimeError(_("Function at EA 0x{ea:X} not found.").format(ea=address))
        function_addr = function.start_ea
        func_name = idc.get_func_name(function_addr) or ""
        func_new_name = names.pop("__function__", None)

        rename_pairs = []
        if func_new_name and func_name.startswith("sub_"):
            rename_pairs.append((func_name, func_new_name))
        rename_pairs.extend((key, value) for key, value in names.items())
        rename_mapping = {old: new for old, new in rename_pairs}

        if not rename_pairs:
            return {"count": 0, "cancelled": False}

        class RenameChoose(ida_kernwin.Choose):
            def __init__(self, pairs):
                super().__init__(
                    _("Select names to rename"),
                    [[_("Old Name"), 20], [_("New Name"), 20]],
                    flags=ida_kernwin.Choose.CH_MULTI,
                )
                self.items = [[old, new] for old, new in pairs]
                self.selected_indices = []

            def OnGetLine(self, index):
                return self.items[index]

            def OnGetSize(self):
                return len(self.items)

            def OnSelectionChange(self, sel_list):
                self.selected_indices = sel_list

        chooser = RenameChoose(rename_pairs)
        if chooser.Show(modal=True) < 0:
            return {"count": 0, "cancelled": True}

        chosen_pairs = [rename_pairs[i] for i in chooser.selected_indices]
        replaced: list[str] = []
        for old, new in chosen_pairs:
            if old == func_name:
                if idc.set_name(function_addr, new, idaapi.SN_FORCE):
                    replaced.append(old)
            else:
                if idaapi.IDA_SDK_VERSION < 760 and view and hasattr(view, "cfunc"):
                    lvars = {lvar.name: lvar for lvar in view.cfunc.lvars}
                    if old in lvars and view.rename_lvar(lvars[old], new, True):
                        replaced.append(old)
                else:
                    if ida_hexrays.rename_lvar(function_addr, old, new):
                        replaced.append(old)

        comment_text = idc.get_func_cmt(address, 0) or ""
        if comment_text and replaced:
            for old in replaced:
                if old in rename_mapping:
                    comment_text = re.sub(r"\b%s\b" % re.escape(old), rename_mapping[old], comment_text)
            idc.set_func_cmt(address, comment_text, 0)

        if view:
            view.refresh_view(True)

        return {"count": len(replaced), "cancelled": False}

    try:
        outcome = run_on_main_thread(_apply, write=True) or {"count": 0, "cancelled": False}
    except Exception as exc:
        error_message = _("[ERROR] rename callback failed: {error}").format(error=str(exc))
        print(error_message)
        STATUS_PANEL.mark_error(error_message)
        return

    if outcome.get("cancelled"):
        STATUS_PANEL.log(_("Rename cancelled by user."), category=LogCategory.TOOL)
        print(_("Rename cancelled by user."))
        return

    count = int(outcome.get("count", 0) or 0)
    response_finished = _("Done! {count} name(s) renamed.").format(count=count)
    print(response_finished)
    STATUS_PANEL.log(response_finished, category=LogCategory.TOOL, level=LogLevel.SUCCESS)


# -----------------------------------------------------------------------------

class RenameHandler(idaapi.action_handler_t):
    """
    This handler requests new names for the function and its variables from the model
    and updates the decompiler's output.
    """

    def __init__(self):
        idaapi.action_handler_t.__init__(self)

    def activate(self, ctx):
        decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())
        v = ida_hexrays.get_widget_vdui(ctx.widget)
        start_time = time.time()
        locale = gepetto.config.get_localization_locale()
        gepetto.config.model.query_model_async(
            f"""
                You are a reverse-engineering assistant refining identifiers.
                - Locale: {locale}
                - Task: Suggest better names for the function and its locals when the improvement is meaningful.
                - Output: Return exactly one JSON object (no Markdown, no backticks, no commentary).
                    Keys = original identifiers, values = suggested replacements.
                    Use the special key "__function__" to propose a new function name.
                - Guidance:
                    * Only include entries where the proposed name clearly improves clarity.
                    * Prefer descriptive, conventional names; avoid Hungarian notation and over-abbreviations.
                    * Leverage existing accurate comments (especially Gepetto banners) when inferring intent.
                - If nothing needs renaming, respond with {{}}.

                ```C
                {decompiler_output}
                ```
              """,
            functools.partial(rename_callback, address=idaapi.get_screen_ea(), view=v, start_time=start_time),
            additional_model_options={"response_format": {"type": "json_object"}})
        request_sent = STATUS_PANEL.log_request_started()
        print(request_sent)
        return 1

    # This action is always available.
    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS


# -----------------------------------------------------------------------------

class SwapModelHandler(idaapi.action_handler_t):
    """
    This handler replaces the model currently in use with another one selected by the user,
    and updates the configuration.
    """

    def __init__(self, new_model, plugin):
        self.new_model = new_model
        self.plugin = plugin

    def activate(self, ctx):
        try:
            gepetto.config.model = instantiate_model(self.new_model)
        except ValueError as e:  # Raised if an API key is missing. In which case, don't switch.
            error_msg = _("Couldn't change model to {model}: {error}").format(model=self.new_model, error=str(e))
            print(error_msg)
            STATUS_PANEL.log(error_msg, category=LogCategory.SYSTEM, level=LogLevel.ERROR)
            return
        gepetto.config.update_config("Gepetto", "MODEL", self.new_model)
        STATUS_PANEL.set_model(str(gepetto.config.model))
        # Refresh the menus to reflect which model is currently selected.
        self.plugin.generate_model_select_menu()

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS


class GenerateCCodeHandler(idaapi.action_handler_t):
    """
    This handler requests the model to generate executable C code from the given
    decompiled C function. The generated code is saved to a file.
    """
    def __init__(self):
        idaapi.action_handler_t.__init__(self)

    def activate(self, ctx):
        decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())
        v = ida_hexrays.get_widget_vdui(ctx.widget)
        if not decompiler_output:
            return 0

        start_time = time.time()
        gepetto.config.model.query_model_async(
            f"Please generate executable C code based on the following decompiled C code and ensure it includes all necessary header files and other information:\n"
            f"{decompiler_output}",
            functools.partial(self._save_c_code, view=v, start_time=start_time)
        )
        request_sent = STATUS_PANEL.log_request_started()
        print(request_sent)
        return 1

    def _save_c_code(self, view, response, start_time):
        """
        Callback that saves the generated C code to a file.
        :param view: A handle to the decompiler window
        :param response: The generated C code from the model
        :param start_time: When the request was initiated
        """

        elapsed_time = time.time() - start_time
        timer_finished = STATUS_PANEL.log_request_finished(elapsed_time)
        print(timer_finished)
        
        code_text = response.content if hasattr(response, "content") else response
        project_name = idaapi.get_root_filename()
        func_name = idc.get_func_name(idaapi.get_screen_ea())
        file_name = f"{project_name}_{func_name}.c"
        with open(file_name, "w", encoding="utf-8") as f:
            f.write(str(code_text))

        if view:
            run_on_main_thread(lambda: view.refresh_view(False))
        response_finished = _("{model} generated code saved to {file_name}").format(
            model=str(gepetto.config.model), file_name=file_name)

        STATUS_PANEL.log(response_finished, category=LogCategory.TOOL, level=LogLevel.SUCCESS)
        print(response_finished)

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS


class GeneratePythonCodeHandler(idaapi.action_handler_t):
    """
    This handler requests the model to generate executable C code from the given
    decompiled C function. The generated code is saved to a file.
    """
    def __init__(self):
        idaapi.action_handler_t.__init__(self)

    def activate(self, ctx):
        decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())
        v = ida_hexrays.get_widget_vdui(ctx.widget)
        if not decompiler_output:
            return 0

        start_time = time.time()
        gepetto.config.model.query_model_async(
            f"Please generate equivalent Python code based on the following decompiled C code, and provide an example of the function call:"
            f"{decompiler_output}",
            functools.partial(self._save_python_code, view=v, start_time=start_time)
        )
        request_sent = STATUS_PANEL.log_request_started()
        print(request_sent)
        return 1

    def _save_python_code(self, view, response, start_time):
        """
        Callback that saves the generated python code to a file.
        :param view: A handle to the decompiler window
        :param response: The generated python code from the model
        :param start_time: When the request was initiated
        """

        elapsed_time = time.time() - start_time
        timer_finished = STATUS_PANEL.log_request_finished(elapsed_time)
        print(timer_finished)
        
        code_text = response.content if hasattr(response, "content") else response
        if not isinstance(code_text, str):
            code_text = str(code_text)
        project_name = idaapi.get_root_filename()
        func_name = idc.get_func_name(idaapi.get_screen_ea())
        file_name = f"{project_name}_{func_name}.py"
        with open(file_name, "w", encoding="utf-8") as f:
            f.write(code_text)

        if view:
            run_on_main_thread(lambda: view.refresh_view(False))
        response_finished = _("{model} generated code saved to {file_name}").format(
            model=str(gepetto.config.model), file_name=file_name)

        STATUS_PANEL.log(response_finished, category=LogCategory.TOOL, level=LogLevel.SUCCESS)
        print(response_finished)

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS
