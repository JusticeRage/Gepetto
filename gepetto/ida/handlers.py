import functools
import json
import re
import time
import textwrap

import idaapi
import ida_hexrays
import ida_kernwin
import idc

import gepetto.config
from gepetto.ida.status_panel import panel as STATUS
from gepetto.ida.utils.ida9_utils import safe_get_screen_ea, run_on_main_thread, touch_last_ea, decompile_func
from gepetto.models.model_manager import instantiate_model

_ = gepetto.config._


def comment_callback(address, view, response, start_time):
    """Callback that sets a comment at the given address.

    :param address: The address of the function to comment
    :param view: A handle to the decompiler window
    :param response: The comment to add, which may be a plain string or a
        Response object from the unified API. The textual content is extracted
        and applied as function comment.
    """
    if getattr(STATUS, "_stopped", False):
        return
    elapsed_time = time.time() - start_time

    def _to_text(resp):
        # Plain string
        if isinstance(resp, str):
            return resp
        # OpenAI Responses Python SDK convenience property
        txt = getattr(resp, "output_text", None)
        if isinstance(txt, str) and txt:
            return txt
        # Direct content attr
        txt = getattr(resp, "content", None)
        if isinstance(txt, str) and txt:
            return txt
        # Gemini/OpenAI pseudo response shape: { output: [ {type:"output_text", content:[{text:"..."}]} ] }
        out = getattr(resp, "output", None)
        if isinstance(out, list):
            parts = []
            for item in out:
                try:
                    if isinstance(item, dict) and item.get("type") == "output_text":
                        for c in item.get("content", []) or []:
                            t = c.get("text") if isinstance(c, dict) else None
                            if isinstance(t, str) and t:
                                parts.append(t)
                except Exception:
                    continue
            if parts:
                return "".join(parts)
        # Fallback stringification
        try:
            return str(getattr(resp, "text", "") or "")
        except Exception:
            return ""
    response_text = _to_text(response)
    response_text = "\n".join(textwrap.wrap(response_text, 80, replace_whitespace=False))

    # Add/update the function comment on IDA's main thread
    def _apply_comment():
        try:
            # Preserve any existing non-Gepetto comment content
            existing = idc.get_func_cmt(address, 0) or ""
            existing = re.sub(
                r'----- ' + _("Comment generated by Gepetto") + ' -----.*?----------------------------------------',
                r"",
                existing,
                flags=re.DOTALL,
            )
            idc.set_func_cmt(
                address,
                '----- ' + _("Comment generated by Gepetto") +
                f" -----\n\n" +
                f"{response_text.strip()}\n\n" +
                f"----------------------------------------\n\n" +
                f"{existing.strip()}",
                0,
            )
            # Refresh the window so the comment is displayed properly
            if view:
                view.refresh_view(False)
        except Exception:
            return 0
        return 1

    run_on_main_thread(_apply_comment, write=True)
    print(_("{model} query finished in {time:.2f} seconds!").format(model=str(gepetto.config.model), time=elapsed_time))

# -----------------------------------------------------------------------------

def conversation_callback(response, memory):
    """Callback that prints the model's response in IDA's output window.

    The ``response`` argument can be a plain string or a Responses API
    object; only the textual content is relevant here.
    """

    def _to_text(resp):
        if isinstance(resp, str):
            return resp
        txt = getattr(resp, "output_text", None)
        if isinstance(txt, str) and txt:
            return txt
        return getattr(resp, "content", "") or ""
    text = _to_text(response)
    memory.append({"role": "assistant", "content": text})

    print()
    STATUS.log(f"{str(gepetto.config.model)}: {text}")
    for line in text.split("\n"):
        if not line.strip():
            continue
        print(f"{str(gepetto.config.model)}> {line}")
    print()

# -----------------------------------------------------------------------------

class ExplainHandler(idaapi.action_handler_t):
    """
    This handler is tasked with querying the model for an explanation of the
    given function. Once the reply is received, it is added as a function
    comment.
    """

    def __init__(self):
        idaapi.action_handler_t.__init__(self)

    def activate(self, ctx):
        start_time = time.time()
        decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())
        v = ida_hexrays.get_widget_vdui(ctx.widget)
        try:
            STATUS.reset_stop()
            STATUS.set_stop_callback(lambda: getattr(gepetto.config.model, "cancel_current_request", lambda: None)())
        except Exception:
            pass
        gepetto.config.model.query_model_async(
            f"""
                You are a reverse-engineering assistant. Output plain text only (no Markdown, no code fences).
                - Respond in locale: {gepetto.config.get_localization_locale()}
                - Task: Explain what this C function does and, if helpful, suggest a better function name.
                - Acceleration: If there are high-quality and accurate existing comments (especially "----- Comment generated by Gepetto -----"):
                   use them to accelerate and improve your explanation.
                - Output format:
                    - First provide a concise explanation.
                    - Then add a final line in the form: "Proposed name: <name>" (or "Proposed name: (no change)" if none).
                \n
                ```C
                {decompiler_output}
                ```
              """,
            functools.partial(comment_callback, address=idaapi.get_screen_ea(), view=v, start_time=start_time))
        print(_("Request to {model} sent...").format(model=str(gepetto.config.model)))
        return 1

    # This action is always available.
    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS


# -----------------------------------------------------------------------------

def rename_callback(address, view, response):
    """
    Callback that extracts a JSON object of old names and new names from the response,
    displays a table UI where the user can select which identifiers to rename,
    and applies renaming only to selected items.
    :param address: The address of the function to work on
    :param view: A handle to the decompiler window
    :param response: The response from the model
    """
    import ida_kernwin
    import json
    import re

    def _to_text(resp):
        if isinstance(resp, str):
            return resp
        txt = getattr(resp, "output_text", None)
        if isinstance(txt, str) and txt:
            return txt
        txt = getattr(resp, "content", None)
        if isinstance(txt, str) and txt:
            return txt
        out = getattr(resp, "output", None)
        if isinstance(out, list):
            parts = []
            for item in out:
                try:
                    if isinstance(item, dict) and item.get("type") == "output_text":
                        for c in item.get("content", []) or []:
                            t = c.get("text") if isinstance(c, dict) else None
                            if isinstance(t, str) and t:
                                parts.append(t)
                except Exception:
                    continue
            if parts:
                return "".join(parts)
        return str(getattr(resp, "text", "") or "")
    if getattr(STATUS, "_stopped", False):
        return
    response_text = _to_text(response)
    names = json.loads(response_text)

    def _do():
        try:
            function_addr = idaapi.get_func(address).start_ea
            func_name = idc.get_func_name(function_addr)
            func_new_name = names.pop("__function__", None)

            rename_pairs = []
            if func_new_name and func_name.startswith("sub_"):
                rename_pairs.append((func_name, func_new_name))
            rename_pairs.extend((n, names[n]) for n in names)
            rename_mapping = {old: new for old, new in rename_pairs}

            class RenameChoose(ida_kernwin.Choose):
                def __init__(self, rename_pairs):
                    super().__init__(
                        _("Select names to rename"),
                        [[_("Old Name"), 20], [_("New Name"), 20]],
                        flags=ida_kernwin.Choose.CH_MULTI,
                    )
                    self.items = [[old, new] for old, new in rename_pairs]
                    self.selected_indices = []

                def OnGetLine(self, n):
                    return self.items[n]

                def OnGetSize(self):
                    return len(self.items)

                def OnSelectionChange(self, sel_list):
                    self.selected_indices = sel_list

            chooser = RenameChoose(rename_pairs)
            if chooser.Show(modal=True) < 0:
                try:
                    print(_("Rename cancelled by user."))
                except Exception:
                    pass
                return 1

            # Get all selected rows
            chosen_pairs = [rename_pairs[i] for i in chooser.selected_indices]

            replaced = []
            for old, new in chosen_pairs:
                if old == func_name:
                    if idc.set_name(function_addr, new, idaapi.SN_FORCE):
                        replaced.append(old)
                else:
                    # Target IDA >= 7.6: use modern lvar access
                    if ida_hexrays.rename_lvar(function_addr, old, new):
                            replaced.append(old)

            comment = idc.get_func_cmt(address, 0)
            if comment and len(replaced) > 0:
                for n in replaced:
                    if n in rename_mapping:
                        comment = re.sub(r'\b%s\b' % n, rename_mapping[n], comment)
                idc.set_func_cmt(address, comment, 0)

            if view:
                view.refresh_view(True)
            try:
                STATUS.log(_("Done! {count} name(s) renamed.").format(count=len(replaced)))
                print(_("Done! {count} name(s) renamed.").format(count=len(replaced)))
            except Exception:
                pass
        except Exception:
            return 0
        return 1

    run_on_main_thread(_do, write=True)


# -----------------------------------------------------------------------------

class RenameHandler(idaapi.action_handler_t):
    """
    This handler requests new names for the function and its variables from the model
    and updates the decompiler's output.
    """

    def __init__(self):
        idaapi.action_handler_t.__init__(self)

    def activate(self, ctx):
        decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())
        v = ida_hexrays.get_widget_vdui(ctx.widget)
        gepetto.config.model.query_model_async(
            f"""
                You are a formatter. Output exactly one JSON object and nothing else. The first character of your response MUST be "{{" and
                the last MUST be "}}". You MUST NOT use Markdown, backticks, or code fences. No explanations, no preface, no suffix. If compliance is
                impossible, output {{}}.
                - Respond with names in locale: {gepetto.config.get_localization_locale()}
                - Acceleration: If there are high-quality and accurate existing comments (especially "----- Comment generated by Gepetto -----"):
                   use them to accelerate and improve your naming.
                - Task: Analyze the following C function and suggest better names for the variables and, if helpful, the function itself.
                - Scope: Only include an entry when the proposed name is at least marginally better than the original.
                - Judgment: Prefer descriptive, conventional names that reflect role, type, and side effects; avoid unnecessary abbreviations and Hungarian notation.
                - Output format (hard requirements):
                    - Return EXACTLY ONE top-level JSON object: each KEY is an original identifier name, each VALUE is its suggested new name (both strings).
                    - Use the special key "__function__" (string) for the function's new name.
                    - Strict JSON only: double-quoted keys/values, proper escaping, no trailing commas.
                    - No text outside the JSON object, no Markdown, no code fences, no remarks.
                    - If there are no qualifying names, return {{}}.
                \n
                ```C
                {decompiler_output}
                ```
              """,
            functools.partial(rename_callback, address=idaapi.get_screen_ea(), view=v),
            additional_model_options={"response_format": {"type": "json_object"}})
        print(_("Request to {model} sent...").format(model=str(gepetto.config.model)))
        return 1

    # This action is always available.
    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS


# -----------------------------------------------------------------------------

class SwapModelHandler(idaapi.action_handler_t):
    """
    This handler replaces the model currently in use with another one selected by the user,
    and updates the configuration.
    """

    def __init__(self, new_model, plugin):
        self.new_model = new_model
        self.plugin = plugin

    def activate(self, ctx):
        try:
            gepetto.config.model = instantiate_model(self.new_model)
        except ValueError as e:  # Raised if an API key is missing. In which case, don't switch.
            print(_("Couldn't change model to {model}: {error}").format(model=self.new_model, error=str(e)))
            return
        gepetto.config.update_config("Gepetto", "MODEL", self.new_model)
        # Refresh the menus to reflect which model is currently selected.
        self.plugin.generate_model_select_menu()

        # Update status panel
        try:
            STATUS.ensure_shown()
            STATUS.set_model(str(gepetto.config.model))
            STATUS.set_status(_("Switched model"), busy=False)
            STATUS.log(_("Model switched to: {model_name}.").format(model_name=self.new_model))
        except Exception as e:
            try:
                print(_("Failed to update status panel: {error}").format(error=e))
            except Exception:
                pass

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS


class GenerateCCodeHandler(idaapi.action_handler_t):
    """
    This handler requests the model to generate executable C code from the given
    decompiled C function. The generated code is saved to a file.
    """
    def __init__(self):
        idaapi.action_handler_t.__init__(self)

    def activate(self, ctx):
        decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())
        v = ida_hexrays.get_widget_vdui(ctx.widget)
        if not decompiler_output:
            return 0

        try:
            STATUS.reset_stop()
            STATUS.set_stop_callback(lambda: getattr(gepetto.config.model, "cancel_current_request", lambda: None)())
        except Exception:
            pass

        gepetto.config.model.query_model_async(
            f"""
                You are a code generator.
                - Respond in locale: {gepetto.config.get_localization_locale()}
                - Task: Generate compilable C source code equivalent to the following decompiled C function.
                - Acceleration: If there are high-quality and accurate existing comments (especially "----- Comment generated by Gepetto -----"):
                   use them to infer intent and accelerate completion.
                - Requirements:
                  - Include all necessary headers and prototypes.
                  - Preserve observable behavior and signatures when inferable.
                  - Output only valid C code; no explanations or remarks.

                ```C
                {decompiler_output}
                ```
              """,
            functools.partial(self._save_c_code, view=v)
        )
        print(_("Request to {model} sent...").format(model=str(gepetto.config.model)))
        return 1

    def _save_c_code(self, view, response):
        """
        Callback that saves the generated C code to a file.
        :param view: A handle to the decompiler window
        :param response: The generated C code from the model
        """
        if getattr(STATUS, "_stopped", False):
            return
        # Extract the code text in a provider-agnostic way
        def _to_text(resp):
            if isinstance(resp, str):
                return resp
            txt = getattr(resp, "output_text", None)
            if isinstance(txt, str) and txt:
                return txt
            txt = getattr(resp, "content", None)
            if isinstance(txt, str) and txt:
                return txt
            out = getattr(resp, "output", None)
            if isinstance(out, list):
                parts = []
                for item in out:
                    if isinstance(item, dict) and item.get("type") == "output_text":
                        for c in item.get("content", []) or []:
                            t = c.get("text") if isinstance(c, dict) else None
                            if isinstance(t, str) and t:
                                parts.append(t)
                if parts:
                    return "".join(parts)
            return str(getattr(resp, "text", "") or "")

        text = _to_text(response)

        # Gather file naming info and refresh on UI thread
        container = {"file_name": None}
        def _gather_and_refresh():
            try:
                project_name = idaapi.get_root_filename()
                func_name = idc.get_func_name(idaapi.get_screen_ea())
                container["file_name"] = f"{project_name}_{func_name}.c"
                if view:
                    view.refresh_view(False)
            except Exception:
                return 0
            return 1

        run_on_main_thread(_gather_and_refresh, write=True)

        file_name = container["file_name"] or "generated.c"
        try:
            with open(file_name, "w", encoding="utf-8") as f:
                f.write(text)
        except Exception:
            pass

        STATUS.log(_("{model} generated code saved to {file_name}").format(model=str(gepetto.config.model), file_name=file_name))
        print(_("{model} generated code saved to {file_name}").format(model=str(gepetto.config.model), file_name=file_name))

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS


class GeneratePythonCodeHandler(idaapi.action_handler_t):
    """
    This handler requests the model to generate executable C code from the given
    decompiled C function. The generated code is saved to a file.
    """
    def __init__(self):
        idaapi.action_handler_t.__init__(self)

    def activate(self, ctx):
        decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())
        v = ida_hexrays.get_widget_vdui(ctx.widget)
        if not decompiler_output:
            return 0

        try:
            STATUS.reset_stop()
            STATUS.set_stop_callback(lambda: getattr(gepetto.config.model, "cancel_current_request", lambda: None)())
        except Exception as e:
            print(e)
            pass

        gepetto.config.model.query_model_async(
            f"""
                You are a code translator.
                - Respond in locale: {gepetto.config.get_localization_locale()}
                - Task: Produce equivalent, runnable Python 3 code for the following decompiled C function, plus a short example call.
                - Acceleration: If there are high-quality and accurate existing comments (especially "----- Comment generated by Gepetto -----"):
                   use them to infer intent and accelerate completion.
                - Requirements:
                  - Use idiomatic Python; include necessary imports and stubs for external dependencies.
                  - Preserve semantics; when unsure, add clear TODO comments within code rather than prose.
                  - Output only Python code (example may be at the bottom).

                ```C
                {decompiler_output}
                ```
              """,
            functools.partial(self._save_python_code, view=v)
        )
        print(_("Request to {model} sent...").format(model=str(gepetto.config.model)))
        return 1

    def _save_python_code(self, view, response):
        """
        Callback that saves the generated python code to a file.
        :param view: A handle to the decompiler window
        :param response: The generated python code from the model
        """
        if getattr(STATUS, "_stopped", False):
            return
        # Extract text robustly across providers
        def _to_text(resp):
            if isinstance(resp, str):
                return resp
            txt = getattr(resp, "output_text", None)
            if isinstance(txt, str) and txt:
                return txt
            txt = getattr(resp, "content", None)
            if isinstance(txt, str) and txt:
                return txt
            out = getattr(resp, "output", None)
            if isinstance(out, list):
                parts = []
                for item in out:
                    if isinstance(item, dict) and item.get("type") == "output_text":
                        for c in item.get("content", []) or []:
                            t = c.get("text") if isinstance(c, dict) else None
                            if isinstance(t, str) and t:
                                parts.append(t)
                if parts:
                    return "".join(parts)
            return str(getattr(resp, "text", "") or "")

        text = _to_text(response)

        container = {"file_name": None}
        def _gather_and_refresh():
            try:
                project_name = idaapi.get_root_filename()
                func_name = idc.get_func_name(idaapi.get_screen_ea())
                container["file_name"] = f"{project_name}_{func_name}.py"
                if view:
                    view.refresh_view(False)
            except Exception as e:
                print(e)
                return 0
            return 1
        run_on_main_thread(_gather_and_refresh, write=True)

        file_name = container["file_name"] or "generated.py"
        try:
            with open(file_name, "w", encoding="utf-8") as f:
                f.write(text)
        except Exception as e:
            print(e)
            pass

        STATUS.log(_("{model} generated code saved to {file_name}").format(model=str(gepetto.config.model), file_name=file_name))
        print(_("{model} generated code saved to {file_name}").format(model=str(gepetto.config.model), file_name=file_name))

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS
