import functools
import json
import re
import time
import textwrap

import idaapi
import ida_hexrays
import idc

import gepetto.config
from gepetto.ida.status_panel import panel as STATUS
from gepetto.models.model_manager import instantiate_model

_ = gepetto.config._


def comment_callback(address, view, response, start_time):
    """Callback that sets a comment at the given address.

    :param address: The address of the function to comment
    :param view: A handle to the decompiler window
    :param response: The comment to add, which may be a plain string or a
        Response object from the unified API. The textual content is extracted
        and applied as function comment.
    """
    if getattr(STATUS, "_stopped", False):
        return
    elapsed_time = time.time() - start_time

    def _to_text(resp):
        if isinstance(resp, str):
            return resp
        txt = getattr(resp, "output_text", None)
        if isinstance(txt, str) and txt:
            return txt
        return getattr(resp, "content", "") or ""
    response_text = _to_text(response)
    response_text = "\n".join(textwrap.wrap(response_text, 80, replace_whitespace=False))

    # Add the response as a comment in IDA, but preserve any existing non-Gepetto comment
    comment = idc.get_func_cmt(address, 0)
    comment = re.sub(
        r'----- ' + _("Comment generated by Gepetto") + ' -----.*?----------------------------------------',
        r"",
        comment,
        flags=re.DOTALL)

    idc.set_func_cmt(address, '----- ' + _("Comment generated by Gepetto") +
                     f" -----\n\n"
                     f"{response_text.strip()}\n\n"
                     f"----------------------------------------\n\n"
                     f"{comment.strip()}", 0)
    # Refresh the window so the comment is displayed properly
    if view:
        view.refresh_view(False)
    print(_("{model} query finished in {time:.2f} seconds!").format(model=str(gepetto.config.model), time=elapsed_time))

# -----------------------------------------------------------------------------

def conversation_callback(response, memory):
    """Callback that prints the model's response in IDA's output window.

    The ``response`` argument can be a plain string or a Responses API
    object; only the textual content is relevant here.
    """

    def _to_text(resp):
        if isinstance(resp, str):
            return resp
        txt = getattr(resp, "output_text", None)
        if isinstance(txt, str) and txt:
            return txt
        return getattr(resp, "content", "") or ""
    text = _to_text(response)
    memory.append({"role": "assistant", "content": text})

    print()
    STATUS.log(_(f"{str(gepetto.config.model)}: {text}"))
    for line in text.split("\n"):
        if not line.strip():
            continue
        print(f"{str(gepetto.config.model)}> {line}")
    print()

# -----------------------------------------------------------------------------

class ExplainHandler(idaapi.action_handler_t):
    """
    This handler is tasked with querying the model for an explanation of the
    given function. Once the reply is received, it is added as a function
    comment.
    """

    def __init__(self):
        idaapi.action_handler_t.__init__(self)

    def activate(self, ctx):
        start_time = time.time()
        decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())
        v = ida_hexrays.get_widget_vdui(ctx.widget)
        try:
            STATUS.reset_stop()
            STATUS.set_stop_callback(lambda: getattr(gepetto.config.model, "cancel_current_request", lambda: None)())
        except Exception:
            pass
        gepetto.config.model.query_model_async(
            f"Can you explain what the following C function does and suggest a better name for it?\n"
            f"Your response should use the following locale as a language: {gepetto.config.get_localization_locale()}\n"
            f"{decompiler_output}",
            functools.partial(comment_callback, address=idaapi.get_screen_ea(), view=v, start_time=start_time))
        print(_("Request to {model} sent...").format(model=str(gepetto.config.model)))
        return 1

    # This action is always available.
    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS


# -----------------------------------------------------------------------------

def rename_callback(address, view, response):
    """
    Callback that extracts a JSON object of old names and new names from the response,
    displays a table UI where the user can select which identifiers to rename,
    and applies renaming only to selected items.
    :param address: The address of the function to work on
    :param view: A handle to the decompiler window
    :param response: The response from the model
    """
    import ida_kernwin
    import json
    import re

    def _to_text(resp):
        if isinstance(resp, str):
            return resp
        txt = getattr(resp, "output_text", None)
        if isinstance(txt, str) and txt:
            return txt
        return getattr(resp, "content", "") or ""
    if getattr(STATUS, "_stopped", False):
        return
    response_text = _to_text(response)
    names = json.loads(response_text)

    function_addr = idaapi.get_func(address).start_ea
    func_name = idc.get_func_name(function_addr)
    func_new_name = names.pop("__function__", None)

    rename_pairs = []
    if func_new_name and func_name.startswith("sub_"):
        rename_pairs.append((func_name, func_new_name))
    rename_pairs.extend((n, names[n]) for n in names)
    rename_mapping = {old: new for old, new in rename_pairs}

    class RenameChoose(ida_kernwin.Choose):
        def __init__(self, rename_pairs):
            super().__init__(
                "Select names to rename",
                [["Old Name", 20], ["New Name", 20]],
                flags=ida_kernwin.Choose.CH_MULTI,
            )
            self.items = [[old, new] for old, new in rename_pairs]
            self.selected_indices = []

        def OnGetLine(self, n):
            return self.items[n]

        def OnGetSize(self):
            return len(self.items)
            
        def OnSelectionChange(self, sel_list):
            self.selected_indices = sel_list

    chooser = RenameChoose(rename_pairs)
    if chooser.Show(modal=True) < 0:
        print(_("Rename cancelled by user."))
        return

    # Get all selected rows
    chosen_pairs = [rename_pairs[i] for i in chooser.selected_indices]

    replaced = []
    for old, new in chosen_pairs:
        if old == func_name:
            if idc.set_name(function_addr, new, idaapi.SN_FORCE):
                replaced.append(old)
        else:
            if idaapi.IDA_SDK_VERSION < 760:
                lvars = {lvar.name: lvar for lvar in view.cfunc.lvars}
                if old in lvars and view.rename_lvar(lvars[old], new, True):
                    replaced.append(old)
            else:
                if ida_hexrays.rename_lvar(function_addr, old, new):
                    replaced.append(old)

    comment = idc.get_func_cmt(address, 0)
    if comment and len(replaced) > 0:
        for n in replaced:
            if n in rename_mapping:
                comment = re.sub(r'\b%s\b' % n, rename_mapping[n], comment)
        idc.set_func_cmt(address, comment, 0)

    if view:
        view.refresh_view(True)
    STATUS.log(_(f"Done! {len(replaced)} name(s) renamed."))
    print(_("Done! {count} name(s) renamed.").format(count=len(replaced)))


# -----------------------------------------------------------------------------

class RenameHandler(idaapi.action_handler_t):
    """
    This handler requests new names for the function and its variables from the model
    and updates the decompiler's output.
    """

    def __init__(self):
        idaapi.action_handler_t.__init__(self)

    def activate(self, ctx):
        decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())
        v = ida_hexrays.get_widget_vdui(ctx.widget)
        gepetto.config.model.query_model_async(
            f"Analyze the following C function:\n{decompiler_output}"
            f"\nSuggest better names for the variables and, if helpful, the function itself."
            f" Return a JSON object where keys are the original names and values are the suggested ones."
            f" Only include an entry when the proposed name is at least marginally better than the original."
            f" Use the special key '__function__' to rename the function. Do not provide any explanation,"
            f" only the JSON object.\n"
            f"Your response should suggest names in the following locale: {gepetto.config.get_localization_locale()}",
            functools.partial(rename_callback, address=idaapi.get_screen_ea(), view=v),
            additional_model_options={"response_format": {"type": "json_object"}})
        print(_("Request to {model} sent...").format(model=str(gepetto.config.model)))
        return 1

    # This action is always available.
    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS


# -----------------------------------------------------------------------------

class SwapModelHandler(idaapi.action_handler_t):
    """
    This handler replaces the model currently in use with another one selected by the user,
    and updates the configuration.
    """

    def __init__(self, new_model, plugin):
        self.new_model = new_model
        self.plugin = plugin

    def activate(self, ctx):
        try:
            gepetto.config.model = instantiate_model(self.new_model)
        except ValueError as e:  # Raised if an API key is missing. In which case, don't switch.
            print(_("Couldn't change model to {model}: {error}").format(model=self.new_model, error=str(e)))
            return
        gepetto.config.update_config("Gepetto", "MODEL", self.new_model)
        # Refresh the menus to reflect which model is currently selected.
        self.plugin.generate_model_select_menu()

        # Update status panel
        try:
            STATUS.ensure_shown()
            STATUS.set_model(str(gepetto.config.model))
            STATUS.set_status(_("Switched model"), busy=False)
            STATUS.log(_(f"Model switched to: {self.new_model}."))
        except Exception as e:
            try:
                print(f"Failed to update status panel: {e}")
            except Exception:
                pass

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS


class GenerateCCodeHandler(idaapi.action_handler_t):
    """
    This handler requests the model to generate executable C code from the given
    decompiled C function. The generated code is saved to a file.
    """
    def __init__(self):
        idaapi.action_handler_t.__init__(self)

    def activate(self, ctx):
        decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())
        v = ida_hexrays.get_widget_vdui(ctx.widget)
        if not decompiler_output:
            return 0

        try:
            STATUS.reset_stop()
            STATUS.set_stop_callback(lambda: getattr(gepetto.config.model, "cancel_current_request", lambda: None)())
        except Exception:
            pass

        gepetto.config.model.query_model_async(
            _("Please generate executable C code based on the following decompiled C code and ensure it includes all necessary header files and other information:\n{decompiler_output}").format(decompiler_output=str(decompiler_output)),
            functools.partial(self._save_c_code, view=v)
        )
        print(_("Request to {model} sent...").format(model=str(gepetto.config.model)))
        return 1

    def _save_c_code(self, view, response):
        """
        Callback that saves the generated C code to a file.
        :param view: A handle to the decompiler window
        :param response: The generated C code from the model
        """
        if getattr(STATUS, "_stopped", False):
            return
        project_name = idaapi.get_root_filename()
        func_name = idc.get_func_name(idaapi.get_screen_ea())
        file_name = f"{project_name}_{func_name}.c"
        text = getattr(response, "output_text", None)
        if not isinstance(text, str):
            text = str(text or getattr(response, "content", ""))
        with open(file_name, "w", encoding="utf-8") as f:
            f.write(text)

        if view:
            view.refresh_view(False)
        STATUS.log(_(f"{str(gepetto.config.model)} generated code saved to {file_name}"))
        print(_("{model} generated code saved to {file_name}").format(model=str(gepetto.config.model), file_name=file_name))

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS


class GeneratePythonCodeHandler(idaapi.action_handler_t):
    """
    This handler requests the model to generate executable C code from the given
    decompiled C function. The generated code is saved to a file.
    """
    def __init__(self):
        idaapi.action_handler_t.__init__(self)

    def activate(self, ctx):
        decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())
        v = ida_hexrays.get_widget_vdui(ctx.widget)
        if not decompiler_output:
            return 0

        try:
            STATUS.reset_stop()
            STATUS.set_stop_callback(lambda: getattr(gepetto.config.model, "cancel_current_request", lambda: None)())
        except Exception:
            pass

        gepetto.config.model.query_model_async(
            _("Please generate equivalent Python code based on the following decompiled C code, and provide an example of the function call:\n{decompiler_output}").format(decompiler_output=str(decompiler_output)),
            functools.partial(self._save_python_code, view=v)
        )
        print(_("Request to {model} sent...").format(model=str(gepetto.config.model)))
        return 1

    def _save_python_code(self, view, response):
        """
        Callback that saves the generated python code to a file.
        :param view: A handle to the decompiler window
        :param response: The generated python code from the model
        """
        if getattr(STATUS, "_stopped", False):
            return
        project_name = idaapi.get_root_filename()
        func_name = idc.get_func_name(idaapi.get_screen_ea())
        file_name = f"{project_name}_{func_name}.py"
        text = getattr(response, "output_text", None)
        if not isinstance(text, str):
            text = str(text or getattr(response, "content", ""))
        with open(file_name, "w", encoding="utf-8") as f:
            f.write(text)

        if view:
            view.refresh_view(False)
        STATUS.log(_(f"{str(gepetto.config.model)} generated code saved to {file_name}"))
        print(_("{model} generated code saved to {file_name}").format(model=str(gepetto.config.model), file_name=file_name))

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS
