import functools
import json
import re
import time
import textwrap

import idaapi
import ida_hexrays
import idc

import gepetto.config
from gepetto.models.model_manager import instantiate_model

_ = gepetto.config._


def comment_callback(address, view, response, start_time):
    """
    Callback that sets a comment at the given address.
    :param address: The address of the function to comment
    :param view: A handle to the decompiler window
    :param response: The comment to add
    """
    elapsed_time = time.time() - start_time
    response = "\n".join(textwrap.wrap(response, 80, replace_whitespace=False))

    # Add the response as a comment in IDA, but preserve any existing non-Gepetto comment
    comment = idc.get_func_cmt(address, 0)
    comment = re.sub(
        r'----- ' + _("Comment generated by Gepetto") + ' -----.*?----------------------------------------',
        r"",
        comment,
        flags=re.DOTALL)

    idc.set_func_cmt(address, '----- ' + _("Comment generated by Gepetto") +
                     f" -----\n\n"
                     f"{response.strip()}\n\n"
                     f"----------------------------------------\n\n"
                     f"{comment.strip()}", 0)
    # Refresh the window so the comment is displayed properly
    if view:
        view.refresh_view(False)
    print(_("{model} query finished in {time:.2f} seconds!").format(model=str(gepetto.config.model), time=elapsed_time))

# -----------------------------------------------------------------------------

def conversation_callback(response, memory):
    """
    Callback that simply prints the model's response in IDA's output window.
    :param response: The response returned by the model
    :param memory: The list of messages exchanged so far, so that it can be updated.
    :return:
    """
    memory.append({"role": "assistant", "content": response})

    print()
    for line in response.split("\n"):
        if not line.strip():
            continue
        print(f"{str(gepetto.config.model)}> {line}")
    print()

# -----------------------------------------------------------------------------

class ExplainHandler(idaapi.action_handler_t):
    """
    This handler is tasked with querying the model for an explanation of the
    given function. Once the reply is received, it is added as a function
    comment.
    """

    def __init__(self):
        idaapi.action_handler_t.__init__(self)

    def activate(self, ctx):
        start_time = time.time()
        decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())
        v = ida_hexrays.get_widget_vdui(ctx.widget)
        gepetto.config.model.query_model_async(
            _("Can you explain what the following C function does and suggest a better name for "
              "it?\n{decompiler_output}").format(decompiler_output=str(decompiler_output)),
            functools.partial(comment_callback, address=idaapi.get_screen_ea(), view=v, start_time=start_time))
        print(_("Request to {model} sent...").format(model=str(gepetto.config.model)))
        return 1

    # This action is always available.
    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS


# -----------------------------------------------------------------------------

def rename_callback(address, view, response):
    """
    Callback that extracts a JSON array of old names and new names from the
    response and sets them in the pseudocode.
    :param address: The address of the function to work on
    :param view: A handle to the decompiler window
    :param response: The response from the model
    """
    names = json.loads(response)

    # The rename function needs the start address of the function
    function_addr = idaapi.get_func(address).start_ea

    replaced = []
    for n in names:
        if idaapi.IDA_SDK_VERSION < 760:
            lvars = {lvar.name: lvar for lvar in view.cfunc.lvars}
            if n in lvars:
                if view.rename_lvar(lvars[n], names[n], True):
                    replaced.append(n)
        else:
            if ida_hexrays.rename_lvar(function_addr, n, names[n]):
                replaced.append(n)

    # Update possible names left in the function comment
    comment = idc.get_func_cmt(address, 0)
    if comment and len(replaced) > 0:
        for n in replaced:
            comment = re.sub(r'\b%s\b' % n, names[n], comment)
        idc.set_func_cmt(address, comment, 0)

    # Refresh the window to show the new names
    if view:
        view.refresh_view(True)
    print(_("{model} query finished! {replaced} variable(s) renamed.").format(model=str(gepetto.config.model),
                                                                              replaced=len(replaced)))


# -----------------------------------------------------------------------------

class RenameHandler(idaapi.action_handler_t):
    """
    This handler requests new variable names from the model and updates the
    decompiler's output.
    It now uses a two-step process:
    1. Ask the model for an explanation of the function.
    2. Use that explanation as context to ask for better variable names.
    """

    def __init__(self):
        idaapi.action_handler_t.__init__(self)

    def _explanation_callback(self, address, view, decompiler_output, response):
        """
        This callback receives the explanation and triggers the second request for renaming.
        """
        print(_("--- FUNCTION EXPLANATION ---"))
        print(response)
        print(_("--- END EXPLANATION ---"))
        print(_("Step 2/2: Function explanation received. Now asking for variable names..."))
        print()
        # Enhanced rename prompt with better instructions for analysis
        rename_prompt = (
            "An expert reverse engineer has provided the following explanation for a C function:\n"
            "--- EXPLANATION ---\n"
            f"{response}\n"
            "--- END EXPLANATION ---\n\n"
            "Based on that explanation, analyze the original C function below and suggest better variable names.\n\n"
            "Guidelines for variable naming:\n"
            "1. Use descriptive names that reflect the variable's purpose and role\n"
            "2. Consider the variable's type, usage pattern, and context within the function\n"
            "3. Follow C naming conventions (snake_case or camelCase)\n"
            "4. For loop counters, use meaningful names like 'index', 'count', 'offset' instead of 'i', 'j'\n"
            "5. For buffers, include size information like 'buffer_size', 'data_length'\n"
            "6. For pointers, indicate what they point to like 'current_node', 'next_element'\n"
            "7. For flags/booleans, use clear names like 'is_valid', 'has_error', 'should_continue'\n"
            "8. For function parameters, consider their role: 'input_data', 'output_buffer', 'config_params'\n"
            "9. Only rename variables that would benefit from more descriptive names\n"
            "10. Keep names reasonably concise but meaningful\n\n"
            "Reply with a JSON dictionary where keys are the original names and values are the proposed names.\n"
            "Only include variables that should be renamed for better code readability.\n"
            "Do not explain anything, only print the JSON dictionary.\n"
            "Example: {\"v1\": \"buffer_size\", \"a2\": \"input_data\", \"result\": \"decrypted_data\"}\n"
            "\n\n"
            "--- C FUNCTION ---\n"
            f"{decompiler_output}"
        )

        # Step 2: Call the model again, but this time for the renames.
        gepetto.config.model.query_model_async(
            rename_prompt,
            functools.partial(rename_callback, address=address, view=view),
            additional_model_options={"response_format": {"type": "json_object"}}
        )

    def activate(self, ctx):
        decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())
        v = ida_hexrays.get_widget_vdui(ctx.widget)
        address = idaapi.get_screen_ea()

        print(_("Step 1/2: Asking for an explanation of the function to improve context..."))

        # Enhanced explanation prompt for better analysis
        explain_prompt = (
            "Analyze the following C function and provide a CONCISE summary (maximum 200 words).\n\n"
            "Focus only on the most important aspects:\n"
            "1. Main purpose and core functionality\n"
            "2. Key variables and their roles (especially unclear variable names like v1, v2, a1, etc.)\n"
            "3. Important data processing or algorithms\n"
            "4. Critical operations (loops, conditions, transformations)\n\n"
            "Be brief but include enough detail to understand variable purposes.\n"
            "DO NOT suggest variable names - only explain what the function does and what each variable represents.\n"
            "This explanation will be used as context for a separate renaming step.\n\n"
            "--- C FUNCTION ---\n"
            f"{decompiler_output}"
        )
        
        gepetto.config.model.query_model_async(
            explain_prompt,
            functools.partial(self._explanation_callback, address=address, view=v, decompiler_output=decompiler_output)
        )
        
        return 1

    # This action is always available.
    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS


# -----------------------------------------------------------------------------

class SwapModelHandler(idaapi.action_handler_t):
    """
    This handler replaces the model currently in use with another one selected by the user,
    and updates the configuration.
    """

    def __init__(self, new_model, plugin):
        self.new_model = new_model
        self.plugin = plugin

    def activate(self, ctx):
        try:
            gepetto.config.model = instantiate_model(self.new_model)
        except ValueError as e:  # Raised if an API key is missing. In which case, don't switch.
            print(_("Couldn't change model to {model}: {error}").format(model=self.new_model, error=str(e)))
            return
        gepetto.config.update_config("Gepetto", "MODEL", self.new_model)
        # Refresh the menus to reflect which model is currently selected.
        self.plugin.generate_model_select_menu()

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS


class GenerateCCodeHandler(idaapi.action_handler_t):
    """
    This handler requests the model to generate executable C code from the given
    decompiled C function. The generated code is saved to a file.
    """
    def __init__(self):
        idaapi.action_handler_t.__init__(self)

    def activate(self, ctx):
        decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())
        v = ida_hexrays.get_widget_vdui(ctx.widget)
        if not decompiler_output:
            return 0

        gepetto.config.model.query_model_async(
            _("Please generate executable C code based on the following decompiled C code and ensure it includes all necessary header files and other information:\n{decompiler_output}").format(decompiler_output=str(decompiler_output)),
            functools.partial(self._save_c_code, view=v)
        )
        print(_("Request to {model} sent...").format(model=str(gepetto.config.model)))
        return 1

    def _save_c_code(self, view, response):
        """
        Callback that saves the generated C code to a file.
        :param view: A handle to the decompiler window
        :param response: The generated C code from the model
        """
        project_name = idaapi.get_root_filename()
        func_name = idc.get_func_name(idaapi.get_screen_ea())
        file_name = f"{project_name}_{func_name}.c"
        with open(file_name, "w", encoding="utf-8") as f:
            f.write(response)

        if view:
            view.refresh_view(False)
        print(_("{model} generated code saved to {file_name}").format(model=str(gepetto.config.model), file_name=file_name))

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS


class GeneratePythonCodeHandler(idaapi.action_handler_t):
    """
    This handler requests the model to generate executable C code from the given
    decompiled C function. The generated code is saved to a file.
    """
    def __init__(self):
        idaapi.action_handler_t.__init__(self)

    def activate(self, ctx):
        decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())
        v = ida_hexrays.get_widget_vdui(ctx.widget)
        if not decompiler_output:
            return 0

        gepetto.config.model.query_model_async(
            _("Please generate equivalent Python code based on the following decompiled C code, and provide an example of the function call:\n{decompiler_output}").format(decompiler_output=str(decompiler_output)),
            functools.partial(self._save_python_code, view=v)
        )
        print(_("Request to {model} sent...").format(model=str(gepetto.config.model)))
        return 1

    def _save_python_code(self, view, response):
        """
        Callback that saves the generated python code to a file.
        :param view: A handle to the decompiler window
        :param response: The generated python code from the model
        """
        project_name = idaapi.get_root_filename()
        func_name = idc.get_func_name(idaapi.get_screen_ea())
        file_name = f"{project_name}_{func_name}.py"
        with open(file_name, "w", encoding="utf-8") as f:
            f.write(response)

        if view:
            view.refresh_view(False)
        print(_("{model} generated code saved to {file_name}").format(model=str(gepetto.config.model), file_name=file_name))

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS
